const { test, expect } = require('@playwright/test');
const TestHelpers = require('../utils/test-helpers');

test.describe('After Hour Insight', () => {
    let config;
    let helpers;

  test.beforeAll(async ({ browser }) => {
        const page = await browser.newPage();
        helpers = new TestHelpers(page);
        config = await helpers.getConfig();
        await page.close();
    });

  test.beforeEach(async ({ page }) => {
        helpers = new TestHelpers(page);
        await helpers.clearStorageAndSetTimeouts();
        
        // Set timeouts
        test.setTimeout(600000); // 10 minutes for long test
    });
    
    test('should redirect to After Hour Insight', async ({ page }) => {
        const helpers = new TestHelpers(page);
        config = await helpers.getConfig();

        // Use fast login helper which handles stored auth vs fresh login automatically
        await helpers.loginAndNavigateToPage(config.urls.fleetMainDashboard);

        // Click on alerts menu
        await expect(page.locator(config.selectors.navigation.alertsMenu)).toBeVisible();
        await page.locator(config.selectors.navigation.alertsMenu).click();

        // Click on after hours summary menu
        await expect(page.locator(config.selectors.afterHoursInsights.afterHoursInsightsMenu)).toBeVisible();
        await page.locator(config.selectors.afterHoursInsights.afterHoursInsightsMenu).click();
            
        // Verify the after hours settings container is visible
        await expect(page.locator(config.selectors.afterHoursInsights.afterHoursInsightsContainer))
            .toBeVisible();
        await expect(page.locator(config.selectors.afterHoursInsights.afterHoursInsightsContainer))
            .toContainText('After Hours Insights');

        // Date selection - use JavaScript to set Flatpickr date directly (input is readonly)
        await page.waitForTimeout(3000);

        // Debug: Check if Flatpickr exists and set date
        const dateSetResult = await page.evaluate(() => {
            const dateInput = document.querySelector('#after-hours-insights-panel input[type="text"]');
            if (!dateInput) {
                return { success: false, error: 'Input not found' };
            }

            // Try different ways to access Flatpickr
            let fp = dateInput._flatpickr || window._flatpickr;

            // If not found, try finding it from the Flatpickr instances
            if (!fp && window.flatpickr) {
                // Get all flatpickr instances
                const allInputs = document.querySelectorAll('.flatpickr-input');
                for (const input of allInputs) {
                    if (input._flatpickr) {
                        fp = input._flatpickr;
                        break;
                    }
                }
            }

            if (fp) {
                // Set the date using Flatpickr's setDate method
                fp.setDate(['2026-01-14', '2026-01-15'], true);
                return { success: true, value: dateInput.value };
            } else {
                return { success: false, error: 'Flatpickr instance not found' };
            }
        });

        console.log('Date set result:', JSON.stringify(dateSetResult));

        if (!dateSetResult.success) {
            console.log('Warning: Failed to set date using Flatpickr. Error:', dateSetResult.error);
        } else {
            console.log('Date set to:', dateSetResult.value);
        }

        await page.waitForTimeout(1000);

        // Click on submit button
        await page.locator(config.selectors.afterHoursInsights.submitButton).click({ force: true });
        console.log('✓ Submit button clicked');

        await page.waitForTimeout(10000);

        // Check what vehicles are available
        const allVehicleCards = page.locator('.vehicle-card');
        const vehicleCount = await allVehicleCards.count();
        console.log(`Found ${vehicleCount} vehicle cards`);

        // Log the names of available vehicles
        for (let i = 0; i < Math.min(vehicleCount, 5); i++) {
            const vehicleName = await allVehicleCards.nth(i).locator('.vehicle-card__title').textContent();
            console.log(`  Vehicle ${i + 1}: ${vehicleName}`);
        }

        // Search for a specific vehicle
        await expect(page.locator(config.selectors.afterHoursInsights.searchInput)).toBeVisible();
        await page.locator(config.selectors.afterHoursInsights.searchInput).clear();
        await page.locator(config.selectors.afterHoursInsights.searchInput).fill('Sales Car1');
        await page.waitForTimeout(2000);
        console.log('✓ Searched for "Sales Car1"');

        // Find the Sales Car1 card and get its values
        const salesCarCard = page.locator('.vehicle-card').filter({ hasText: 'Sales Car1' });
        await expect(salesCarCard.locator('.vehicle-card__title')).toBeVisible({ timeout: 10000 });

        // Get and trim the Within Hours value (authorized)
        const authorizedValue = await salesCarCard.locator('.vehicle-card__value--authorized').textContent();
        const authorizedHours = authorizedValue?.trim() || '';

        // Get and trim the Outside Hours value (unauthorized)
        const unauthorizedValue = await salesCarCard.locator('.vehicle-card__value--unauthorized').textContent();
        const unauthorizedHours = unauthorizedValue?.trim() || '';

        await salesCarCard.locator('.vehicle-card__title').click();

        await page.waitForTimeout(10000); // Wait for the modal to open

        await expect(page.locator('#authorized-hours-panel')).toBeVisible();
        await expect(page.locator('#authorized-hours-panel')).toContainText('Sales Car1');
        console.log('✓ Modal opened with Sales Car1');

        // Wait for modal content to fully load
        await page.waitForTimeout(3000);

        // Skip the card comparison as the modal structure is different
        // The values are already validated when we stored them from the vehicle card
        console.log(`Stored Authorized Hours: ${authorizedHours}`);
        console.log(`Stored Unauthorized Hours: ${unauthorizedHours}`);

        // Add this code after the modal opens and is visible
        await expect(page.locator('#authorized-hours-panel')).toBeVisible();
        await expect(page.locator('#authorized-hours-panel')).toContainText('Sales Car1');

        // Helper functions for time conversion
        const timeToSeconds = (timeStr) => {
            if (!timeStr || timeStr === '') return 0;
            const parts = timeStr.split(':').map(part => parseInt(part, 10));
            if (parts.length === 3) {
                return parts[0] * 3600 + parts[1] * 60 + parts[2];
            } else if (parts.length === 2) {
                return parts[0] * 60 + parts[1];
            }
            return 0;
        };

        const secondsToTime = (totalSeconds) => {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        };

        // Function to calculate duration from all pages
        const calculateAllPagesDuration = async () => {
            let totalDurationSeconds = 0;
            const allDurations = [];

            // Wait for pagination to stabilize
            await page.waitForTimeout(2000);

            // Click on page 1 first to reset
            const firstPageButton = page.locator('.pagination__controls .pagination__page').first();
            if (await firstPageButton.count() > 0) {
                await firstPageButton.click({ force: true });
                await page.waitForTimeout(1500);
            }

            // Process pages dynamically without pre-counting
            let currentPage = 1;
            let hasMorePages = true;

            while (hasMorePages) {
                console.log(`Processing page ${currentPage}`);

                // Wait for table to load
                await page.waitForTimeout(1000);

                const rows = page.locator('#locations-table tbody tr');
                const rowCount = await rows.count();
                let pageCount = 0;

                // Process current page data
                if (rowCount === 0) {
                    console.log(`Page ${currentPage}: No data, stopping...`);
                    break;
                }

                for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
                    try {
                        const durationText = await rows.nth(rowIndex).locator('td').nth(4).textContent({ timeout: 5000 });
                        const trimmedDuration = durationText?.trim();

                        if (trimmedDuration && trimmedDuration !== '') {
                            allDurations.push(trimmedDuration);
                            totalDurationSeconds += timeToSeconds(trimmedDuration);
                            pageCount++;
                        }
                    } catch (e) {
                        console.log(`Failed to read row ${rowIndex + 1} on page ${currentPage}: ${e.message}`);
                    }
                }

                console.log(`Page ${currentPage}: ${pageCount} entries, running total: ${secondsToTime(totalDurationSeconds)}`);

                // Check if we can go to next page
                const nextPageButton = page.locator('.pagination__controls .pagination__page').nth(currentPage);

                // Check if next page button exists and is not the current active page
                const nextExists = (await nextPageButton.count()) > 0;
                const isNextActive = nextExists && (await nextPageButton.getAttribute('class'))?.includes('active');

                if (nextExists && !isNextActive) {
                    // Click next page
                    await nextPageButton.scrollIntoViewIfNeeded();
                    await nextPageButton.click({ force: true });
                    await page.waitForTimeout(1500);
                    currentPage++;
                } else {
                    // No more pages
                    console.log(`Page ${currentPage}: Last page reached`);
                    hasMorePages = false;
                }
            }

            const finalResult = secondsToTime(totalDurationSeconds);
            console.log(`Total entries processed: ${allDurations.length}`);
            console.log(`Final total: ${finalResult}`);
            return finalResult;
        };

        // Test 1: Click on "All" tab and calculate total duration
        console.log('=== Testing ALL tab (all pages) ===');
        await page.locator('button[data-tab="all"]').click({ force: true });
        await page.waitForTimeout(3000); // Wait for tab content to load

        const allTabDuration = await calculateAllPagesDuration();
        console.log(`All tab calculated duration: ${allTabDuration}`);

        // Test 2: Click on "Authorized" tab and calculate authorized duration
        console.log('=== Testing AUTHORIZED tab (all pages) ===');
        await page.locator('button[data-tab="authorized"]').click({ force: true });
        await page.waitForTimeout(3000); // Wait for tab content and pagination to update

        const authorizedTabDuration = await calculateAllPagesDuration();
        console.log(`Authorized tab calculated duration: ${authorizedTabDuration}`);

        // Test 3: Click on "Unauthorized" tab and calculate unauthorized duration
        console.log('=== Testing UNAUTHORIZED tab (all pages) ===');
        await page.locator('button[data-tab="unauthorized"]').click({ force: true });
        await page.waitForTimeout(3000); // Wait for tab content and pagination to update

        const unauthorizedTabDuration = await calculateAllPagesDuration();
        console.log(`Unauthorized tab calculated duration: ${unauthorizedTabDuration}`);

        // Get the summary card values (from the top of the modal) instead of the detailed cards
        console.log(`=== USING SUMMARY CARD VALUES ===`);
        console.log(`Summary Authorized: ${authorizedHours}`);
        console.log(`Summary Unauthorized: ${unauthorizedHours}`);
        
        // Calculate summary total
        const summaryTotalSeconds = timeToSeconds(authorizedHours) + timeToSeconds(unauthorizedHours);
        const summaryTotal = secondsToTime(summaryTotalSeconds);
        
        console.log(`Summary Total: ${summaryTotal}`);
        
        console.log(`=== COMPARISON 2: Authorized Tab vs Summary Authorized ===`);
        console.log(`Authorized tab (all pages): ${authorizedTabDuration}`);
        console.log(`Summary authorized: ${authorizedHours}`);
        expect(authorizedTabDuration).toBe(authorizedHours);
        
        console.log(`=== COMPARISON 3: Unauthorized Tab vs Summary Unauthorized ===`);
        console.log(`Unauthorized tab (all pages): ${unauthorizedTabDuration}`);
        console.log(`Summary unauthorized: ${unauthorizedHours}`);
        expect(unauthorizedTabDuration).toBe(unauthorizedHours);

        // Verification: All = Authorized + Unauthorized (from calculated tabs)
        const calculatedTotalSeconds = timeToSeconds(authorizedTabDuration) + timeToSeconds(unauthorizedTabDuration);
        const calculatedTotal = secondsToTime(calculatedTotalSeconds);
        
        console.log(`=== VERIFICATION: Math Check ===`);
        console.log(`Authorized (${authorizedTabDuration}) + Unauthorized (${unauthorizedTabDuration}) = ${calculatedTotal}`);
        console.log(`All tab shows: ${allTabDuration}`);
        
        expect(allTabDuration).toBe(calculatedTotal);

        // Final comprehensive summary
        console.log('=== FINAL SUMMARY ===');
        console.log(`✓ All Tab Total: ${allTabDuration}`);
        console.log(`✓ Authorized Tab Total: ${authorizedTabDuration}`);
        console.log(`✓ Unauthorized Tab Total: ${unauthorizedTabDuration}`);
        console.log(`✓ Summary Total: ${summaryTotal}`);
        console.log(`✓ Summary Authorized: ${authorizedHours}`);
        console.log(`✓ Summary Unauthorized: ${unauthorizedHours}`);

        // Close the modal
        console.log('=== CLOSING MODAL ===');
        await page.locator('#authorized-hours-panel .header__btn .icon--close').click();
        await page.waitForTimeout(2000);

        // Verify modal is closed
        await expect(page.locator('#authorized-hours-panel')).not.toBeVisible();
        console.log('✓ Modal closed successfully');

        // Change date to January 7-8, 2026
        console.log('=== CHANGING DATE TO JANUARY 7-8, 2026 ===');
        await page.waitForTimeout(2000);

        // Set new date range using JavaScript to directly manipulate Flatpickr instance
        await page.evaluate(() => {
            const dateInput = document.querySelector('#after-hours-insights-panel input[type="text"]');
            if (dateInput && dateInput._flatpickr) {
                dateInput._flatpickr.setDate(['2026-01-07', '2026-01-08']);
            }
        });
        await page.waitForTimeout(1000);
        console.log('Date set to 2026-01-07 to 2026-01-08');

        // Set up API response interception
        console.log('=== SETTING UP API INTERCEPTION ===');
        let apiResponse = null;

        page.on('response', async (response) => {
            if (response.url().includes('getAferhours_here.php')) {
                try {
                    apiResponse = await response.json();
                    console.log('API Response captured:', JSON.stringify(apiResponse, null, 2));
                } catch (e) {
                    console.log('Failed to parse API response:', e.message);
                }
            }
        });

        // Click submit button
        await page.locator(config.selectors.afterHoursInsights.submitButton).click({ force: true });
        console.log('✓ Submit button clicked');

        // Wait for API response and data to load
        await page.waitForTimeout(10000);

        // Verify API response was captured
        expect(apiResponse).not.toBeNull();
        console.log('✓ API response captured successfully');

        // Verify API response data structure
        expect(apiResponse).toHaveProperty('data');
        expect(Array.isArray(apiResponse.data)).toBe(true);
        console.log(`✓ API returned ${apiResponse.data.length} vehicles`);

        // Verify UI values match API response for each vehicle
        console.log('=== VERIFYING API DATA WITH UI VALUES ===');

        for (const vehicleData of apiResponse.data) {
            const vehicleName = vehicleData.vehicleName.trim();
            console.log(`\nVerifying vehicle: ${vehicleName}`);

            // Find the vehicle card in UI
            const vehicleCard = page.locator('.vehicle-card').filter({ hasText: vehicleName });

            if (await vehicleCard.count() > 0) {
                // Get UI values
                const uiAuthorized = await vehicleCard.locator('.vehicle-card__value--authorized').textContent();
                const uiUnauthorized = await vehicleCard.locator('.vehicle-card__value--unauthorized').textContent();

                const uiAuthorizedTrimmed = uiAuthorized?.trim() || '';
                const uiUnauthorizedTrimmed = uiUnauthorized?.trim() || '';

                // Compare with API values
                console.log(`  API Authorized: ${vehicleData.totalInsideHours}`);
                console.log(`  UI Authorized: ${uiAuthorizedTrimmed}`);
                console.log(`  API Unauthorized: ${vehicleData.totalOutsideHours}`);
                console.log(`  UI Unauthorized: ${uiUnauthorizedTrimmed}`);

                expect(uiAuthorizedTrimmed).toBe(vehicleData.totalInsideHours);
                expect(uiUnauthorizedTrimmed).toBe(vehicleData.totalOutsideHours);

                console.log(`✓ ${vehicleName} - Values match!`);
            } else {
                console.log(`  ⚠ Vehicle card not found in UI for ${vehicleName}`);
            }
        }

        console.log('\n=== API VERIFICATION COMPLETE ===');

        // Test search functionality
        console.log('\n=== TESTING SEARCH FUNCTIONALITY ===');
        await page.waitForTimeout(2000);

        // Find and use the search input
        const searchInput = page.locator('#after-hours-insights-search');
        await expect(searchInput).toBeVisible();
        console.log('✓ Search input is visible');

        // Clear any existing search
        await searchInput.clear();
        await page.waitForTimeout(500);

        // Type "Sales Car1" in the search
        await searchInput.fill('Sales Car1');
        console.log('✓ Typed "Sales Car1" in search');
        await page.waitForTimeout(2000);

        // Get all vehicle cards for search verification
        const searchVehicleCards = page.locator('.vehicle-card');
        const visibleCards = await searchVehicleCards.filter({ has: page.locator(':visible') });
        const visibleCount = await visibleCards.count();

        console.log(`Number of visible vehicle cards: ${visibleCount}`);

        // Verify only one card is visible
        expect(visibleCount).toBe(1);
        console.log('✓ Only 1 vehicle card is visible');

        // Verify the visible card is Sales Car1
        const visibleCard = visibleCards.first();
        const cardTitle = await visibleCard.locator('.vehicle-card__title').textContent();
        const cardTitleTrimmed = cardTitle?.trim() || '';

        console.log(`Visible card title: "${cardTitleTrimmed}"`);
        expect(cardTitleTrimmed).toContain('Sales Car1');
        console.log('✓ Visible card is "Sales Car1"');

        // Set up API interception for table data
        console.log('\n=== SETTING UP API INTERCEPTION FOR TABLE DATA ===');
        let tableApiResponse = null;

        page.on('response', async (response) => {
            if (response.url().includes('datafetch2_insights.php')) {
                try {
                    tableApiResponse = await response.json();
                    console.log('Table API Response captured');
                    console.log('Number of records in API:', tableApiResponse.length || tableApiResponse.data?.length || 0);
                } catch (e) {
                    console.log('Failed to parse table API response:', e.message);
                }
            }
        });

        // Click on the Sales Car1 card
        await visibleCard.locator('.vehicle-card__title').click();
        console.log('✓ Clicked on Sales Car1 card');

        await page.waitForTimeout(5000);

        // Verify the modal opens with Sales Car1 details
        await expect(page.locator('#authorized-hours-panel')).toBeVisible();
        await expect(page.locator('#authorized-hours-panel')).toContainText('Sales Car1');
        console.log('✓ Modal opened with Sales Car1 details');

        console.log('\n=== SEARCH FUNCTIONALITY TEST COMPLETE ===');

        // Verify table data against API response
        console.log('\n=== VERIFYING TABLE DATA WITH API RESPONSE ===');
        await page.waitForTimeout(2000);

        // Wait for table to be visible
        const locationsTable = page.locator('#locations-table');
        await expect(locationsTable).toBeVisible();
        console.log('✓ Locations table is visible');

        // Verify API response was captured
        if (tableApiResponse === null) {
            console.log('⚠ Warning: API response was not captured, waiting longer...');
            await page.waitForTimeout(3000);
        }

        expect(tableApiResponse).not.toBeNull();
        console.log('✓ Table API response captured successfully');

        // Determine the API data array
        let apiData = Array.isArray(tableApiResponse) ? tableApiResponse : tableApiResponse.data;

        if (!apiData || !Array.isArray(apiData)) {
            console.log('API Response structure:', JSON.stringify(tableApiResponse, null, 2));
            throw new Error('API response does not contain an array of data');
        }

        console.log(`Total records in API: ${apiData.length}`);

        // Get table rows (excluding header)
        const tableRows = locationsTable.locator('tbody tr');
        const tableRowCount = await tableRows.count();
        console.log(`Visible table rows: ${tableRowCount}`);

        // Compare first 6-8 rows (whichever is smaller)
        const rowsToCompare = Math.min(8, tableRowCount, apiData.length);
        console.log(`Comparing first ${rowsToCompare} rows`);

        for (let i = 0; i < rowsToCompare; i++) {
            const row = tableRows.nth(i);
            const apiRecord = apiData[i];

            console.log(`\n--- Comparing Row ${i + 1} ---`);

            // Get table cell values
            const tableCells = row.locator('td');
            const tableDate = (await tableCells.nth(0).textContent())?.trim() || '';
            const tableDay = (await tableCells.nth(1).textContent())?.trim() || '';
            const tableTimeRange = (await tableCells.nth(2).textContent())?.trim() || '';
            const tableLocation = (await tableCells.nth(3).locator('p').first().textContent())?.trim() || '';
            const tableDuration = (await tableCells.nth(4).locator('p').first().textContent())?.trim() || '';

            console.log('Table Data:');
            console.log(`  Date: ${tableDate}`);
            console.log(`  Day: ${tableDay}`);
            console.log(`  Time Range: ${tableTimeRange}`);
            console.log(`  Location: ${tableLocation}`);
            console.log(`  Duration: ${tableDuration}`);

            console.log('API Data:');
            console.log(`  Date: ${apiRecord.date || apiRecord.Date || ''}`);
            console.log(`  Day: ${apiRecord.day || apiRecord.Day || apiRecord.dayOfWeek || ''}`);
            console.log(`  Time Range: ${apiRecord.timeRange || apiRecord.time_range || ''}`);
            console.log(`  Location: ${apiRecord.location || apiRecord.Location || ''}`);
            console.log(`  Duration: ${apiRecord.duration || apiRecord.Duration || ''}`);

            // Compare values (flexible field name matching)
            const apiDate = apiRecord.date || apiRecord.Date || '';
            const apiDay = apiRecord.day || apiRecord.Day || apiRecord.dayOfWeek || '';
            const apiTimeRange = apiRecord.timeRange || apiRecord.time_range || apiRecord.TimeRange || '';
            const apiLocation = apiRecord.location || apiRecord.Location || '';
            const apiDuration = apiRecord.duration || apiRecord.Duration || '';

            // Verify each field
            expect(tableDate).toBe(apiDate);
            expect(tableDay).toBe(apiDay);
            expect(tableTimeRange).toBe(apiTimeRange);
            expect(tableLocation).toBe(apiLocation);
            expect(tableDuration).toBe(apiDuration);

            console.log(`✓ Row ${i + 1} matches API data`);
        }

        console.log('\n=== TABLE DATA VERIFICATION COMPLETE ===');
        console.log(`✓ All ${rowsToCompare} rows match the API response`);

        // Test entries per page dropdown
        console.log('\n=== TESTING ENTRIES PER PAGE FUNCTIONALITY ===');
        await page.waitForTimeout(2000);

        const entriesSelect = page.locator('#authorized-hoursentries');
        await expect(entriesSelect).toBeVisible();
        console.log('✓ Entries dropdown is visible');

        // Helper function to verify rows per page
        const verifyRowsPerPage = async (entriesValue) => {
            console.log(`\n--- Testing ${entriesValue} entries per page ---`);

            // Select the entries value
            await entriesSelect.selectOption(entriesValue);
            console.log(`✓ Selected ${entriesValue} entries`);
            await page.waitForTimeout(2000);

            // Get pagination info to determine total pages
            const paginationText = await page.locator('.pagination__showing').textContent();
            console.log(`Pagination info: ${paginationText}`);

            // Extract total entries from pagination text (e.g., "Showing 1 to 25 of 59 entries")
            const match = paginationText?.match(/of (\d+) entries/);
            const totalEntries = match ? parseInt(match[1]) : 0;
            console.log(`Total entries: ${totalEntries}`);

            // Calculate expected pages
            const expectedPages = Math.ceil(totalEntries / parseInt(entriesValue));
            console.log(`Expected pages: ${expectedPages}`);

            // Get all page buttons (excluding prev/next buttons)
            const pageButtons = page.locator('.pagination__controls .pagination__page').filter({ hasNot: page.locator('.pagination__icon') });

            // Check each page
            for (let pageNum = 1; pageNum <= Math.min(expectedPages, 3); pageNum++) {
                console.log(`\n  Checking Page ${pageNum}:`);

                // Click on the page button if not already on page 1
                if (pageNum > 1) {
                    const pageButton = page.locator(`.pagination__controls .pagination__page:has-text("${pageNum}")`).first();
                    if (await pageButton.count() > 0 && await pageButton.isVisible()) {
                        await pageButton.click({ force: true });
                        await page.waitForTimeout(1500);
                    }
                }

                // Count rows in the table
                const tableRows = locationsTable.locator('tbody tr');
                const rowCount = await tableRows.count();

                // Calculate expected rows for this page
                const remainingEntries = totalEntries - ((pageNum - 1) * parseInt(entriesValue));
                const expectedRows = Math.min(parseInt(entriesValue), remainingEntries);

                console.log(`    Expected rows: ${expectedRows}`);
                console.log(`    Actual rows: ${rowCount}`);

                // Verify row count
                expect(rowCount).toBe(expectedRows);
                console.log(`    ✓ Page ${pageNum} has correct number of rows (${rowCount})`);
            }

            // Go back to page 1 for next test
            const page1Button = page.locator('.pagination__controls .pagination__page:has-text("1")').first();
            if (await page1Button.count() > 0 && await page1Button.isVisible()) {
                await page1Button.click({ force: true });
                await page.waitForTimeout(1500);
            }

            console.log(`✓ ${entriesValue} entries per page verified successfully`);
        };

        // Test 25 entries per page
        await verifyRowsPerPage('25');

        // Test 50 entries per page
        await verifyRowsPerPage('50');

        // Test 100 entries per page
        await verifyRowsPerPage('100');

        console.log('\n=== ENTRIES PER PAGE FUNCTIONALITY TEST COMPLETE ===');

        // Test table sorting functionality
        console.log('\n=== TESTING TABLE SORTING FUNCTIONALITY ===');
        await page.waitForTimeout(2000);

        // Reset to 10 entries for easier sorting verification
        await entriesSelect.selectOption('10');
        await page.waitForTimeout(2000);
        console.log('✓ Reset to 10 entries per page for sorting tests');

        // Helper function to get column data
        const getColumnData = async (columnIndex) => {
            const tableRows = locationsTable.locator('tbody tr');
            const rowCount = await tableRows.count();
            const columnData = [];

            for (let i = 0; i < rowCount; i++) {
                const row = tableRows.nth(i);
                const cell = row.locator('td').nth(columnIndex);

                // For cells with nested p tags (Location and Duration)
                if (columnIndex === 3 || columnIndex === 4) {
                    const text = await cell.locator('p').first().textContent();
                    columnData.push(text?.trim() || '');
                } else {
                    const text = await cell.textContent();
                    columnData.push(text?.trim() || '');
                }
            }

            return columnData;
        };

        // Helper function to verify sorting order
        const verifySortOrder = (data, order, columnName) => {
            const sortedData = [...data];

            if (order === 'asc') {
                sortedData.sort((a, b) => {
                    // Handle date sorting
                    if (columnName === 'Date') {
                        return new Date(a) - new Date(b);
                    }
                    // Handle time sorting (HH:MM:SS format)
                    if (columnName === 'Duration') {
                        const timeToSeconds = (time) => {
                            const parts = time.split(':').map(p => parseInt(p));
                            return parts[0] * 3600 + parts[1] * 60 + parts[2];
                        };
                        return timeToSeconds(a) - timeToSeconds(b);
                    }
                    // String sorting
                    return a.localeCompare(b);
                });
            } else {
                sortedData.sort((a, b) => {
                    // Handle date sorting
                    if (columnName === 'Date') {
                        return new Date(b) - new Date(a);
                    }
                    // Handle time sorting (HH:MM:SS format)
                    if (columnName === 'Duration') {
                        const timeToSeconds = (time) => {
                            const parts = time.split(':').map(p => parseInt(p));
                            return parts[0] * 3600 + parts[1] * 60 + parts[2];
                        };
                        return timeToSeconds(b) - timeToSeconds(a);
                    }
                    // String sorting
                    return b.localeCompare(a);
                });
            }

            // Compare arrays
            const isMatch = JSON.stringify(data) === JSON.stringify(sortedData);
            return { isMatch, sortedData };
        };

        // Test sorting for each column
        const columnsToTest = [
            { name: 'Date', index: 0, thIndex: 0 },
            { name: 'Day Of The Week', index: 1, thIndex: 1 },
            { name: 'Time Range', index: 2, thIndex: 2 },
            { name: 'Location', index: 3, thIndex: 3 },
            { name: 'Duration', index: 4, thIndex: 4 }
        ];

        for (const column of columnsToTest) {
            console.log(`\n--- Testing sorting for ${column.name} column ---`);

            // Get the header element
            const headerCell = locationsTable.locator('thead th').nth(column.thIndex);
            await expect(headerCell).toBeVisible();

            // Click to sort ascending
            await headerCell.click();
            await page.waitForTimeout(1500);
            console.log(`  Clicked ${column.name} header (1st click - ascending)`);

            // Get data after first sort
            const dataAfterFirstSort = await getColumnData(column.index);
            console.log(`  Data after 1st sort:`, dataAfterFirstSort.slice(0, 3), '...');

            // Verify ascending order
            const ascResult = verifySortOrder(dataAfterFirstSort, 'asc', column.name);
            if (ascResult.isMatch) {
                console.log(`  ✓ ${column.name} sorted in ASCENDING order correctly`);
            } else {
                console.log(`  Expected (asc):`, ascResult.sortedData.slice(0, 3), '...');
                console.log(`  Got:`, dataAfterFirstSort.slice(0, 3), '...');
            }
            expect(ascResult.isMatch).toBe(true);

            // Click again to sort descending
            await headerCell.click();
            await page.waitForTimeout(1500);
            console.log(`  Clicked ${column.name} header (2nd click - descending)`);

            // Get data after second sort
            const dataAfterSecondSort = await getColumnData(column.index);
            console.log(`  Data after 2nd sort:`, dataAfterSecondSort.slice(0, 3), '...');

            // Verify descending order
            const descResult = verifySortOrder(dataAfterSecondSort, 'desc', column.name);
            if (descResult.isMatch) {
                console.log(`  ✓ ${column.name} sorted in DESCENDING order correctly`);
            } else {
                console.log(`  Expected (desc):`, descResult.sortedData.slice(0, 3), '...');
                console.log(`  Got:`, dataAfterSecondSort.slice(0, 3), '...');
            }
            expect(descResult.isMatch).toBe(true);

            console.log(`  ✓ ${column.name} column sorting verified successfully`);
        }

        console.log('\n=== TABLE SORTING FUNCTIONALITY TEST COMPLETE ===');
        console.log('✓ All column sorters working correctly');

        // Test table search functionality
        console.log('\n=== TESTING TABLE SEARCH FUNCTIONALITY ===');
        await page.waitForTimeout(2000);

        const tableSearchInput = page.locator('#authorized-hours-search');
        await expect(tableSearchInput).toBeVisible();
        console.log('✓ Table search input is visible');

        // Get initial row count
        const initialRows = locationsTable.locator('tbody tr');
        const initialRowCount = await initialRows.count();
        console.log(`Initial row count: ${initialRowCount}`);

        // Helper function to check if row contains search term
        const rowContainsSearchTerm = async (row, searchTerm) => {
            const rowText = await row.textContent();
            return rowText?.toLowerCase().includes(searchTerm.toLowerCase());
        };

        // Test search with different terms
        const searchTerms = [
            { term: 'Scottsdale', description: 'Location search' },
            { term: '2026-01-07', description: 'Date search' },
            { term: 'Wednesday', description: 'Day search' },
            { term: 'AM', description: 'Time search' }
        ];

        for (const searchTest of searchTerms) {
            console.log(`\n--- Testing search: "${searchTest.term}" (${searchTest.description}) ---`);

            // Clear previous search
            await tableSearchInput.clear();
            await page.waitForTimeout(500);

            // Enter search term
            await tableSearchInput.fill(searchTest.term);
            console.log(`  Entered search term: "${searchTest.term}"`);
            await page.waitForTimeout(2000);

            // Get filtered rows
            const filteredRows = locationsTable.locator('tbody tr');
            const filteredRowCount = await filteredRows.count();
            console.log(`  Filtered row count: ${filteredRowCount}`);

            // Verify filtered count is less than or equal to initial count
            expect(filteredRowCount).toBeLessThanOrEqual(initialRowCount);

            // Verify all visible rows contain the search term
            let allRowsMatch = true;
            for (let i = 0; i < filteredRowCount; i++) {
                const row = filteredRows.nth(i);
                const contains = await rowContainsSearchTerm(row, searchTest.term);

                if (!contains) {
                    const rowText = await row.textContent();
                    console.log(`  ✗ Row ${i + 1} does not contain "${searchTest.term}": ${rowText}`);
                    allRowsMatch = false;
                } else {
                    console.log(`  ✓ Row ${i + 1} contains "${searchTest.term}"`);
                }
            }

            expect(allRowsMatch).toBe(true);
            console.log(`  ✓ All ${filteredRowCount} filtered rows contain "${searchTest.term}"`);
        }

        // Clear search and verify all rows are back
        console.log('\n--- Testing search clear ---');
        await tableSearchInput.clear();
        await page.waitForTimeout(2000);
        console.log('  Cleared search input');

        const rowsAfterClear = locationsTable.locator('tbody tr');
        const rowCountAfterClear = await rowsAfterClear.count();
        console.log(`  Row count after clear: ${rowCountAfterClear}`);

        expect(rowCountAfterClear).toBe(initialRowCount);
        console.log('  ✓ All rows restored after clearing search');

        // Test search with no results
        console.log('\n--- Testing search with no results ---');
        await tableSearchInput.fill('XYZNONEXISTENT123');
        console.log('  Entered non-existent search term');
        await page.waitForTimeout(2000);

        const noResultRows = locationsTable.locator('tbody tr');
        const noResultCount = await noResultRows.count();
        console.log(`  Row count: ${noResultCount}`);

        // Depending on implementation, could be 0 rows or a "no results" message row
        if (noResultCount === 0) {
            console.log('  ✓ No rows displayed (as expected)');
        } else {
            // Check if there's a "no results" message
            const firstRowText = await noResultRows.first().textContent();
            console.log(`  Note: ${noResultCount} row(s) displayed. Content: ${firstRowText}`);
        }

        // Clear search to restore table
        await tableSearchInput.clear();
        await page.waitForTimeout(1500);

        console.log('\n=== TABLE SEARCH FUNCTIONALITY TEST COMPLETE ===');
        console.log('✓ Table search working correctly');

        // Test row click and API call for All tab
        console.log('\n=== TESTING ROW CLICK AND API CALL (ALL TAB) ===');
        await page.waitForTimeout(2000);

        // Helper function to wait for API call
        const waitForReverseGeocodeApi = async () => {
            let apiCalled = false;

            const responsePromise = new Promise((resolve) => {
                const handler = async (response) => {
                    if (response.url().includes('reverse_geocodeNew.php')) {
                        apiCalled = true;
                        console.log(`    ✓ API called: ${response.url()}`);
                        page.off('response', handler);
                        resolve(true);
                    }
                };
                page.on('response', handler);
            });

            // Wait for API call with timeout
            const timeoutPromise = new Promise((resolve) => setTimeout(() => resolve(false), 10000));
            const result = await Promise.race([responsePromise, timeoutPromise]);

            return result;
        };

        // Click on first row
        console.log('\n--- Clicking on 1st row of All tab ---');
        const firstRow = locationsTable.locator('tbody tr').first();
        await expect(firstRow).toBeVisible();

        const apiPromise1 = waitForReverseGeocodeApi();
        await firstRow.click();
        console.log('  Clicked on 1st row');

        const apiCalled1 = await apiPromise1;
        expect(apiCalled1).toBe(true);
        console.log('  ✓ reverse_geocodeNew.php API called for 1st row');

        await page.waitForTimeout(2000);

        // Click on second row
        console.log('\n--- Clicking on 2nd row of All tab ---');
        const secondRow = locationsTable.locator('tbody tr').nth(1);
        await expect(secondRow).toBeVisible();

        const apiPromise2 = waitForReverseGeocodeApi();
        await secondRow.click();
        console.log('  Clicked on 2nd row');

        const apiCalled2 = await apiPromise2;
        expect(apiCalled2).toBe(true);
        console.log('  ✓ reverse_geocodeNew.php API called for 2nd row');

        await page.waitForTimeout(2000);

        console.log('\n=== ROW CLICK AND API CALL TEST COMPLETE (ALL TAB) ===');

        // Helper function to test a specific tab (reusable for Authorized and Unauthorized tabs)
        const testTabFunctionality = async (tabName) => {
            console.log(`\n\n========================================`);
            console.log(`   TESTING ${tabName.toUpperCase()} TAB`);
            console.log(`========================================`);

            // Click on the tab
            const tabButton = page.locator(`button[data-tab="${tabName.toLowerCase()}"]`);
            await expect(tabButton).toBeVisible();
            await tabButton.click();
            console.log(`✓ Clicked on ${tabName} tab`);
            await page.waitForTimeout(2000);

            // Verify the tab is active
            await expect(tabButton).toHaveClass(/tabs__btn--active/);
            console.log(`✓ ${tabName} tab is now active`);

            // Get initial row count for this tab
            const tabTableRows = locationsTable.locator('tbody tr');
            const tabInitialRowCount = await tabTableRows.count();
            console.log(`\nInitial row count in ${tabName} tab: ${tabInitialRowCount}`);

            if (tabInitialRowCount === 0) {
                console.log(`⚠ No data in ${tabName} tab, skipping tests for this tab`);
                return;
            }

            // Test 1: Entries per page for this tab
            console.log(`\n--- Testing Entries Per Page for ${tabName} tab ---`);

            const entriesValues = ['25', '50'];
            for (const entriesValue of entriesValues) {
                console.log(`\n  Testing ${entriesValue} entries:`);

                await entriesSelect.selectOption(entriesValue);
                await page.waitForTimeout(2000);

                const paginationText = await page.locator('.pagination__showing').textContent();
                console.log(`  Pagination: ${paginationText}`);

                const match = paginationText?.match(/of (\d+) entries/);
                const totalEntries = match ? parseInt(match[1]) : 0;

                const rowCount = await tabTableRows.count();
                const expectedRows = Math.min(parseInt(entriesValue), totalEntries);

                console.log(`    Expected rows: ${expectedRows}, Actual rows: ${rowCount}`);
                expect(rowCount).toBe(expectedRows);
                console.log(`    ✓ ${entriesValue} entries per page verified`);
            }

            // Reset to 10 entries
            await entriesSelect.selectOption('10');
            await page.waitForTimeout(1500);
            console.log(`  Reset to 10 entries per page`);

            // Test 2: Sorting for this tab
            console.log(`\n--- Testing Sorting for ${tabName} tab ---`);

            // Test a few key columns
            const columnsToTestInTab = [
                { name: 'Date', index: 0, thIndex: 0 },
                { name: 'Duration', index: 4, thIndex: 4 }
            ];

            for (const column of columnsToTestInTab) {
                console.log(`\n  Testing ${column.name} sorting:`);

                const headerCell = locationsTable.locator('thead th').nth(column.thIndex);

                // Ascending sort
                await headerCell.click();
                await page.waitForTimeout(1500);

                const dataAsc = await getColumnData(column.index);
                const ascResult = verifySortOrder(dataAsc, 'asc', column.name);
                console.log(`    Ascending: ${dataAsc.slice(0, 2).join(', ')}...`);
                expect(ascResult.isMatch).toBe(true);
                console.log(`    ✓ Ascending sort verified`);

                // Descending sort
                await headerCell.click();
                await page.waitForTimeout(1500);

                const dataDesc = await getColumnData(column.index);
                const descResult = verifySortOrder(dataDesc, 'desc', column.name);
                console.log(`    Descending: ${dataDesc.slice(0, 2).join(', ')}...`);
                expect(descResult.isMatch).toBe(true);
                console.log(`    ✓ Descending sort verified`);
            }

            // Test 3: Search for this tab
            console.log(`\n--- Testing Search for ${tabName} tab ---`);

            const tabSearchTerms = [
                { term: 'Scottsdale', description: 'Location' },
                { term: '2026-01-07', description: 'Date' }
            ];

            for (const searchTest of tabSearchTerms) {
                console.log(`\n  Searching for "${searchTest.term}" (${searchTest.description}):`);

                await tableSearchInput.clear();
                await page.waitForTimeout(500);

                await tableSearchInput.fill(searchTest.term);
                await page.waitForTimeout(2000);

                const filteredRows = locationsTable.locator('tbody tr');
                const filteredCount = await filteredRows.count();
                console.log(`    Filtered rows: ${filteredCount}`);

                // Verify all rows contain search term
                let allMatch = true;
                for (let i = 0; i < Math.min(filteredCount, 5); i++) {
                    const row = filteredRows.nth(i);
                    const contains = await rowContainsSearchTerm(row, searchTest.term);
                    if (!contains) allMatch = false;
                }

                if (filteredCount > 0) {
                    expect(allMatch).toBe(true);
                    console.log(`    ✓ All rows contain "${searchTest.term}"`);
                } else {
                    console.log(`    Note: No results for "${searchTest.term}"`);
                }
            }

            // Clear search
            await tableSearchInput.clear();
            await page.waitForTimeout(1500);
            console.log(`  ✓ Search cleared`);

            // Test 4: Row click and API call for this tab
            console.log(`\n--- Testing Row Click and API Call for ${tabName} tab ---`);

            // Click on first row
            console.log(`\n  Clicking on 1st row of ${tabName} tab:`);
            const tabFirstRow = locationsTable.locator('tbody tr').first();

            if (await tabFirstRow.count() > 0) {
                const apiPromise1 = waitForReverseGeocodeApi();
                await tabFirstRow.click();
                console.log(`    Clicked on 1st row`);

                const apiCalled1 = await apiPromise1;
                expect(apiCalled1).toBe(true);
                console.log(`    ✓ reverse_geocodeNew.php API called for 1st row`);

                await page.waitForTimeout(2000);

                // Click on second row
                console.log(`\n  Clicking on 2nd row of ${tabName} tab:`);
                const tabSecondRow = locationsTable.locator('tbody tr').nth(1);

                if (await tabSecondRow.count() > 0) {
                    const apiPromise2 = waitForReverseGeocodeApi();
                    await tabSecondRow.click();
                    console.log(`    Clicked on 2nd row`);

                    const apiCalled2 = await apiPromise2;
                    expect(apiCalled2).toBe(true);
                    console.log(`    ✓ reverse_geocodeNew.php API called for 2nd row`);

                    await page.waitForTimeout(2000);
                } else {
                    console.log(`    ⚠ Only 1 row available, skipping 2nd row test`);
                }
            } else {
                console.log(`    ⚠ No rows available for testing`);
            }

            console.log(`\n✓ ${tabName} tab functionality verified successfully\n`);
        };

        // Test Authorized tab
        await testTabFunctionality('Authorized');

        // Test Unauthorized tab
        await testTabFunctionality('Unauthorized');

        // Return to All tab
        console.log('\n--- Returning to All tab ---');
        const allTabButton = page.locator('button[data-tab="all"]');
        await allTabButton.click();
        await page.waitForTimeout(2000);
        console.log('✓ Returned to All tab');

        console.log('\n========================================');
        console.log('   ALL TAB TESTS COMPLETE');
        console.log('========================================');
    });
});