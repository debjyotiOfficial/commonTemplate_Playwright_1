#!/usr/bin/env node
'use strict';

const {spawn} = require('child_process');
const path = require('path');
const helper = require('../../helpers/helper');
const CLIUtils = require('../v2/cliUtils');
const {getLoadConfigPath, sleep} = require('./loadUtils');
const logger = require('../../helpers/logger').winstonLogger;


async function executeLoadTest(yargs) {
  try {
    const rawArgs = process.argv.slice(2);
    const loadArgs = rawArgs.slice(1);

    logger.debug(`Executing load test with arguments: ${loadArgs}`);
    let config = {};

    try {
      logger.debug('Loading configuration using environment variables if available.');
      config = {
        userName: process.env.BROWSERSTACK_USERNAME || process.env.BROWSERSTACK_USER,
        accessKey: process.env.BROWSERSTACK_ACCESS_KEY || process.env.BROWSERSTACK_ACCESSKEY
      };

      if (!config.userName || !config.accessKey) {
        const configPath = getLoadConfigPath(yargs.argv);
        logger.debug(`Configuration path: ${configPath}`);

        if (configPath) {
          config = helper.readConfig(configPath);
        }
      }
    } catch (error) {
      logger.error(`Error loading configuration: ${error.message}`);
      logger.debug(`Error details: ${error.stack || JSON.stringify(error)}`);
      await sleep();  // Added sleep to ensure logs are flushed
      process.exit(1);
    }

    if (!config.userName || !config.accessKey) {
      logger.error('Authentication incomplete. Please add your userName and accessKey to either the browserstack.yml file or as environment variables, then try running the command again.');
      await sleep();
      process.exit(1);
    }

    // Get the CLI directory
    const cliDir = CLIUtils.getCliDir();
    if (!cliDir) {
      logger.error('Failed to determine CLI directory');
      await sleep();
      process.exit(1);
    }

    // Check if CLI binary exists
    let binaryPath = CLIUtils.getExistingCliPath(cliDir);

    // If CLI doesn't exist or needs to be updated, download it
    // Pass config to CLI download/update process
    try {
      if (!binaryPath) {
        logger.debug('CLI binary not found, downloading latest version');
        binaryPath = await CLIUtils.checkAndUpdateCli('', cliDir, config);
      } else {
        logger.debug('CLI binary found, Checking for CLI updates');
        binaryPath = await CLIUtils.checkAndUpdateCli(binaryPath, cliDir, config);
      }
    } catch (error) {
      logger.error('Authentication incomplete. Please add your userName and accessKey to either the browserstack.yml file or as environment variables, then try running the command again.');
      logger.debug(`Error Details: ${error.stack || JSON.stringify(error)}`);
      await sleep();
      process.exit(1);
    }

    if (!binaryPath) {
      logger.error('Authentication incomplete. Please add your userName and accessKey to either the browserstack.yml file or as environment variables, then try running the command again.');
      logger.debug('Failed to download or locate CLI binary');
      await sleep();
      process.exit(1);
    }

    logger.debug(`Spawning: ${binaryPath} load ${loadArgs.join(' ')}`);

    // Pass all arguments directly to the CLI binary
    const childProc = spawn(binaryPath, ['load', ...loadArgs], {
      stdio: 'inherit'
    });

    let isExiting = false;

    // Promise that resolves when the child process exits
    const childProcessPromise = new Promise((resolve) => {
      childProc.on('close', (code) => {
        logger.debug(`${binaryPath} exited with code ${code}`);
        resolve(code);
      });
    });

    // Handle signals like SIGINT (Ctrl+C), SIGTERM, etc.
    ['SIGINT', 'SIGTERM', 'SIGQUIT', 'SIGHUP'].forEach(signal => {
      process.on(signal, () => {
        if (isExiting) {
          return;
        }
        isExiting = true;

        logger.debug(`Received ${signal}, forwarding to child process...`);

        // Forward the signal to the child process
        if (childProc && !childProc.killed) {
          childProc.kill(signal);
          logger.debug('Waiting for child process to exit...');
        }
      });
    });

    // Wait for the child process to complete
    const exitCode = await childProcessPromise;

    // Exit with the same code as the child process
    await sleep();
    process.exit(exitCode);

  } catch (error) {
    logger.error(`Failed initiating load test: ${error.message}`);
    logger.debug(`Error details: ${error.stack || JSON.stringify(error)}`);
    await sleep();
    process.exit(1);
  }
}

module.exports = executeLoadTest;
